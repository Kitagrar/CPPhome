# Сдача плюсов  

## Функции  

1)Объявление и определение.  

Предварительное объявление функции: *void foo(int x)* только прототип без тела функции  

Функция определяет действия, которые выполняет программа. Функции позволяют выделить набор инструкций и назначить ему имя. А затем многократно по присвоенному имени вызывать в различных частях программы. По сути функция - это именованный блок кода.  

Формальное определение функции выглядит следующим образом:  

    тип имя_функции(параметры)
    {
        инструкции
    }

2)Forward declaration.  

В теории программирования термин forward declaration означает декларирование идентификатора (обозначающего такой объект, как тип, переменная или функция) до того, как программист дал ему полное определение. Это требуется для того, чтобы компилятор знал тип идентификатора (чтобы можно было определить необходимый размер памяти для создания объекта, для проверки типа или подписи функции), при этом необязательно идентификатор может содержать значение (в случае переменной).  

3)Встроенные функции.  

Язык C++ предлагает возможность совместить все преимущества функций вместе с высокой производительностью кода, написанного "на месте". Речь идет о встроенных функциях. Ключевое слово inline используется для запроса, чтобы компилятор рассматривал вашу функцию как встроенную. При компиляции вашего кода, все встроенные функции (англ. "inline functions") раскрываются "на месте", то есть вызов функции заменяется копией содержимого самой функции, и ресурсы, которые могли бы быть потрачены на вызов этой функции, сохраняются! Минусом является лишь увеличение компилируемого кода за счет того, что встроенная функция раскрывается в коде при каждом вызове (особенно если она длинная и/или её вызывают много раз). Рассмотрим следующий фрагмент кода:  

    #include <iostream> 

    int max(int a, int b) 
    { 
    return a < b ? b : a; 
    } 

    int main() 
    { 
    std::cout << max(7, 8) << '\n'; 
    std::cout << max(5, 4) << '\n'; 
    return 0; 
    }  

Эта программа дважды вызывает функцию max(), т.е. дважды расходуются ресурсы на вызов функции. Поскольку max() является довольно таки короткой функцией, то это идеальный вариант для её конвертации во встроенную функцию:  

    inline int max(int a, int b) 
    { 
    return a < b ? b : a; 
    }  

Теперь, при компиляции функции main(), ЦП будет читать код следующим образом:  

    int main() 
    { 
    std::cout << (7 < 8 ? 8 : 7) << '\n'; 
    std::cout << (5 < 4 ? 4 : 5) << '\n'; 
    return 0; 
    }  

Такой код выполнится быстрее ценой несколько увеличенного объема  

4)Передача аргументов по значению, указателю и ссылке.  

--**По значению:** при передаче аргументов по значению функция получает копию значения переменных и констант  

    #include <iostream>
    
    void square(int);   // прототип функции
    
    int main()
    {
        int n {4};
        std::cout << "Before square: n = " << n << std::endl;
        square(n);
        std::cout << "After square: n = " << n << std::endl;
    }
    
    void square(int m)
    {
        m = m * m;  // изменяем значение параметра
        std::cout << "In square: m = " << m << std::endl;
    }  

--**по указателю:**в итоге изменение параметра x также повлияет на переменную n, потому что оба они хранят адрес на один и тот же участок памяти:  

    #include <iostream>
    
    void increment(int*);
    
    int main()
    {
        int n {10};
        increment(&n);
        std::cout << "main function: " << n << std::endl;
    }
    void increment(int *x)
    {
        (*x)++; // получаем значение по адресу в x и увеличиваем его на 1
        std::cout << "increment function: " << *x << std::endl;
    }

--**По ссылке:** При передаче параметров по ссылке передается ссылка на объект, через которую мы можем манипулировать самим объектов, а не просто его значением  

    #include <iostream>
    
    void square(int&);   // прототип функции
    
    int main()
    {
        int n {4};
        std::cout << "Before square: n = " << n << std::endl;
        square(n);
        std::cout << "After square: n = " << n << std::endl;
    }
    void square(int& m)
    {
        m = m * m;  // изменяем значение параметра
        std::cout << "In square: m = " << m << std::endl;
    }

5)Аргументы по умолчанию. Статические переменные функции.  

Аргументы по умолчанию яункция может иметь любые  

Использование ключевого слова static с локальными переменными изменяет их свойство продолжительности жизни с автоматического на статическое (или "фиксированное"). Статическая переменная (или «переменная со статической продолжительностью жизни») сохраняет свое значение даже после выхода из блока, в котором она определена. То есть она создается (и инициализируется) только один раз, а затем сохраняется на протяжении выполнения всей программы.  

6)Перегрузка функций. Указатели на функций. Лямбда-функции.  

+ **Перегрузка функций** — это возможность определять несколько функций с одним и тем же именем, но с разными параметрами.Обратите внимание, тип возврата функции НЕ учитывается при перегрузке функции.  

Поскольку все стандартные и пользовательские преобразования считаются равными, то, если вызов функции соответствует нескольким кандидатам посредством стандартного или пользовательского преобразования, результатом будет неоднозначное совпадение  

+ **Указатели на функций**: Указатели на функции аналогичны, за исключением того, что вместо обычных переменных, они указывают на функции!  

+ **Лямбда-функции**:  Лямбда-выражение (или просто «лямбда») в программировании позволяет определить анонимную функцию внутри другой функции. Возможность сделать функцию вложенной является очень важным преимуществом, так как позволяет избегать как захламления пространства имен лишними объектами, так и определить функцию как можно ближе к месту её первого использования.

Лямбда-выражения имеют следующий синтаксис:  

    [ captureClause ] ( параметры ) -> возвращаемыйТип
    {
    стейтменты;
    }

**Также обратите внимание, что лямбда-выражения не имеют имен, поэтому нам и не нужно будет их предоставлять.**

7)Рекурсия. Функциональное программирование. Макросы.  

**Рекурсивная функция** (или просто "рекурсия") в языке C++ — это функция, которая вызывает сама себя  

**Условие завершения рекурсии** — это условие, которое, при его выполнении, остановит вызов рекурсивной функции самой себя. В этом условии обычно используется оператор if.  
**Захват внешней переменной**  

+ `[]` — не захватывать ничего  
+ `[=]` — захватить все по значению  
+ `[&]` — захватить все по ссылке  
+ `[x,y]` — захватить только x и y  по значению  
+ `[&x, &y]` — захватить только x и y  по ссылке  
+ `[=,&x &y]` — захватить x и y по ссылке, а остальное по значению  
+ `[name1 = x, name2 = y]` — инициализирующий захват  

**Функциональное программирование (FP)** - это парадигма программирования, в которой программы строятся на основе функций, которые рассматриваются как основные строительные блоки программы.  

В отличие от императивного программирования, где управление состоянием является ключевым аспектом, в FP функции являются чистыми математическими функциями, которые не имеют побочных эффектов и возвращают результат только на основе своих аргументов. Это означает, что функции в FP не изменяют состояния или переменные вне своей области видимости.  

8)Условная компиляция  

Директивы препроцессора условной компиляции позволяют определить, при каких условиях код будет компилироваться, а при каких — нет. На этом уроке мы рассмотрим только три директивы условной компиляции:  

+ ifdef  
+ #ifndef  
+ #endif  
**Директива #ifdef** (сокр. от "if defined" = "если определено") позволяет препроцессору проверить, было ли значение ранее определено с помощью директивы #define. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код будет проигнорирован.  
**Директива #ifndef** (сокр. от "if not defined" = "если не определено") — это полная противоположность к #ifdef, которая позволяет проверить, не было ли значение ранее определено.  
Условная компиляция очень часто используется в качестве header guards  

# Сдача плюсов  

## Память  

1)Адреса и указатели  

+ **Адрес:** Адрес представляет собой числовое значение, которое идентифицирует положение в памяти компьютера. В C++ вы можете получить адрес переменной с помощью оператора "адрес" (&).  

+ **Указатель:** Указатель - это переменная, которая хранит адрес другой переменной. Указатели в C++ объявляются с помощью символа "*", перед именем переменной.  

+ **Работа с указателями:** Указатели позволяют изменять значения переменных по их адресам. Для этого можно использовать оператор разыменования "*"  

        int number = 10;
        int* ptr = &number;
        *ptr = 20;  

+ **Передача данных по указателю:** Один из основных сценариев использования указателей - передача данных в функцию по указателю. Это используется для того, чтобы функция могла изменить значения переданных ей переменных.  

        void increment(int* ptr) {
            (*ptr)++;
        }

        int main() {
            int number = 10;
            increment(&number);
            // значение переменной number увеличится на 1
            return 0;
        }  

### При работе с указателями в C++ возникают следующие опасности  

+ Некорректные указатели: использование непроинициализированного указателя или указателя, указывающего на удаленную память, может привести к неопределенному поведению программы или краху. От этой опасности можно избавиться, инициализируя указатели перед использованием и проверяя их на нулевое значение перед осуществлением доступа.  

+ Утечка памяти: неверное освобождение памяти, на которую указывает указатель, может привести к утечке памяти. То есть, после использования этой памяти она не будет автоматически освобождена, что может привести к исчерпанию ресурсов системы. Для избежания утечек памяти следует следить за освобождением памяти, выделенной с помощью оператора new, при помощи оператора delete.  

+ Данное использование указателей: некорректное обращение к памяти по указателю может привести к перезаписи данных, которые хранятся в других областях памяти, или краху программы. Чтобы избежать этой опасности, необходимо корректно использовать указатели, следить за доступом к памяти и правильно управлять ее выделением и освобождением.  

+ Неопределенное поведение: использование указателей, не соответствующих типу данных или выходящих за пределы массива, приводит к неопределенному поведению программы. Например, это может вызвать ошибки сегментации или перезапись данных других переменных. Чтобы избежать этой опасности, следует правильно объявлять и использовать указатели, а также выполнять проверки и контролировать доступ к памяти.  

### Для избежания указанных опасностей рекомендуется использовать следующие методы  

+ Использование ссылок вместо указателей, когда это возможно.  

+ Использование умных указателей, таких как std::unique_ptr, std::shared_ptr и std::weak_ptr, которые автоматически управляют выделенной памятью и предотвращают утечку памяти.  
+ Использование операторов new и delete с учетом необходимого выделения и освобождения памяти.  

+ Проверка указателей на нулевое значение перед осуществлением доступа к памяти.  

+ Использование стандартных функций и структур данных, которые обеспечивают безопасное использование указателей, таких как std::deque или std::vector вместо C-стиля массивов.  

### Разница ссылки и указателя  

+ Нельзя объявить массив ссылок.  
+ У ссылки нет адреса.  
+ Существует арифметика указателей, но нет арифметики ссылок.  
+ Указатель может иметь «невалидное» значение с которым его можно сравнить перед использованием.  
+ Ссылка должна быть проинициализирована сразу в момент объявления.  
+ Ссылка привязана к одному и тому же объекту со своего рождения.  

2)_nullptr_ _void*_  

**nullptr** - это ключевое слово, которое представляет нулевое значение для указателей. Оно позволяет явно указывать на то, что указатель не указывает на какой-либо объект или переменную. Ранее в C++ для обозначения нулевых указателей использовался NULL, однако nullptr представляет более безопасный и строгий подход к работе с указателями.  

**_void*_** - это тип указателя на неопределенные данные. То есть, указатель типа **_void*_** может указывать на объект любого типа данных. Однако нельзя разыменовать указатель типа void*, поскольку компилятор не знает, какой именно тип данных содержится по этому адресу. Для работы с указателем типа void* его необходимо привести к конкретному типу, чтобы использовать его значения или изменить данные по этому адресу.  

Обычно nullptr используется для явного указания нулевых указателей, а void* используется, когда необходимо работать с указателями на неопределенные типы данных или в ситуациях, когда тип данных не важен или может различаться.  

3)Сегменты адресного пространства процесса  

+ Сегмент кода (Code Segment):  
Этот сегмент содержит исполняемый код программы, то есть инструкции, которые выполняются процессором. Он доступен только для чтения и выполнения, и он обычно размещается в начале адресного пространства процесса.  

+ Сегмент данных (Data Segment):  
Этот сегмент предназначен для хранения статических или глобальных переменных, которые используются в программе. Он может быть подразделен на две части: сегмент инициализированных данных и сегмент неинициализированных данных (также известный как "BSS" или "Block Started by Symbol"). Сегмент инициализированных данных содержит переменные, которые имеют явно заданные значения, в то время как сегмент неинициализированных данных содержит переменные, которые не имеют явно заданных значений и инициализируются значением по умолчанию (например, нулевым).  

+ Сегмент стека (Stack Segment):
Сегмент стека используется для хранения локальных переменных и вызовов функций в процессе выполнения программы. Он работает по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out), сохраняя информацию о вызовах функций и возвращении из них. Каждый поток выполнения программы обычно имеет свой собственный сегмент стека.

+ Сегмент кучи (Heap Segment):  
Сегмент кучи используется для динамического выделения памяти во время выполнения программы, используя операторы new и delete (или malloc и free в C). В этом сегменте хранятся данные, которые создаются и уничтожаются в процессе выполнения программы по мере необходимости.  

+ Сегмент сегментированных памяти (Segmented Memory Segment):  
Этот сегмент хранит информацию о сегментированной памяти, которая используется в некоторых операционных системах для организации адресного пространства процесса в несколько фрагментов с различными правами доступа. В современных операционных системах сегментацию обычно заменяют плоской моделью памяти.  

4)Глобальные и локальные переменные  

Глобальные переменные объявляются вне всех функций и классов, можно сказать, что они доступны везде в программе. Обычно их объявляют в начале программы и их значение сохраняется до конца программы. Глобальные переменные могут быть использованы в любой функции или классе.  

Локальные переменные объявляются внутри функций или блоков кода и доступны только внутри этого блока. Они существуют только во время выполнения этой функции или блока кода. Локальные переменные могут иметь одно и то же имя, что и глобальные переменные, но будут считаться отдельными переменными. Это объясняется тем, что локальные переменные имеют более высокий приоритет использования, чем глобальные переменные.  

Отличие локальных переменных от глобальных заключается в области видимости. Глобальные переменные видны во всех функциях программы, а локальные переменные видны только внутри функции или блока кода, в котором они объявлены.  

Одна из особенностей локальных переменных заключается в том, что при каждом вызове функции или блока кода создается новая локальная переменная с тем же именем, и после выполнения функции или блока кода эта переменная уничтожается.  

Глобальные переменные могут быть использованы для хранения данных, доступных для всех функций или классов программы, а локальные переменные создаются и используются для временного хранения данных, которые нужны только внутри функции или блока кода.  

### Использование глобальных переменных может привести к следующим проблемам  

+ Запутанность и непредсказуемость кода: Если переменная может быть изменена из разных мест, это может сделать код сложным для понимания и отладки.

+ Конфликты имен переменных: Если в разных частях программы используется глобальная переменная с одинаковым именем, это может привести к ошибкам в результате неожиданного взаимодействия.

+ Зависимость кода: Использование глобальных переменных может привести к тому, что разные части кода станут сильно связанными, что затруднит их тестирование и обновление.

+ Усложнение многопоточности: Если несколько потоков программы могут одновременно изменять глобальные переменные, это может привести к ошибкам синхронизации и неправильному поведению программы.

### Для исправления этих проблем можно использовать следующие подходы

+ Используйте локальные переменные в функциях и классах, которые ограничены областью видимости и доступны только внутри конкретного блока кода.

+ Передавайте переменные в функции и методы в качестве параметров, чтобы изолировать их изменение и упростить код.

+ Используйте объекты и классы, чтобы инкапсулировать состояние и поведение, вместо глобальных переменных.

+ Разделите код на модули или компоненты, чтобы сократить взаимодействие между глобальными переменными разных частей программы.

+ Используйте принципы объектно-ориентированного программирования, такие как наследование и полиморфизм, чтобы сделать код более гибким и изолированным от глобальных переменных.

+ Используйте синхронизацию и мьютексы при работе с глобальными переменными в многопоточной среде, чтобы избежать ошибок синхронизации и состояний гонки.

5)Встроенные статические массивы

**Массив** — совокупный тип данных, который позволяет получить доступ ко всем переменным одного и того же типа данных через использование одного идентификатора  

**Статический массив** – это массив, который объявлен с фиксированным размером в момент компиляции программы. Размер массива определяется в квадратных скобках при его объявлении.  

+ Доступ к элементам массива осуществляется через индексатор, значения индекса от 0 до N-1  
+ Выход за границы массива не контролируется, ошибка может привести к неопределенному поведению.  
+ T a[size] - массив элементов типа T размером size, где size должен быть константным выражением приводимым к типу size_t(Константное выражение — выражение, известное во время компиляции)  

Если массив объявлен статически, то есть в глобальной области видимости, в области видимости пространства имен или в качестве статического члена класса, то он размещается в статической памяти. Массивам, объявленным локально, память выделяется на стеке. (Естественно, надо учитывать ограниченный размер стека при выборе размера локальных массивов.) Нестатические члены класса размещаются в границах экземпляра класса.  

+ Нельзя объявить массив, элементы которого имеют тип void.  
+ Нельзя объявить массив ссылок.(Вместо этого можно использовать массив константных указателей)  
+ Нельзя объявить массив функций.(Вместо этого можно использовать массив указателей на функцию.)  

Статический массив имеет фиксированный размер, поэтому вы не можете добавлять или удалять элементы из него после его создания. Вы можете изменять значения элементов, но не размер массива.  

6)Указатели и ссылки на статический массив  

Распространенная ошибка думать, что переменная array и указатель на array являются одним и тем же объектом. Это не так. Хотя оба указывают на первый  элемент массива, информация о типе данных у них разная. В вышеприведенном примере типом переменной array является int[4], тогда как типом указателя на массив является int *.  

Путаница вызвана тем, что во многих случаях, при вычислении, фиксированный массив распадается (неявно преобразовывается) в указатель на первый элемент массива. Доступ к элементам по-прежнему осуществляется через указатель, но информация, полученная из типа массива (например, его размер), не может быть доступна из типа указателя  

При использовании в фиксированном массиве, оператор sizeof возвращает размер всего массива (длина массива * размер элемента). При использовании с указателем, оператор sizeof возвращает размер адреса памяти (в байтах). Например:  

    #include <iostream> 
    
    int main() 
    { 
    int array[4] = { 5, 8, 6, 4 }; 
     
    std::cout << sizeof(array) << '\n'; // выведется sizeof(int) * длина array 16
     
    int *ptr = array; 
    std::cout << sizeof(ptr) << '\n'; // выведется размер указателя 4
     
    return 0; 
    }  

Второе различие возникает при использовании оператора адреса &. Используя адрес указателя, мы получаем адрес памяти переменной указателя. Используя адрес массива, возвращается указатель на целый массив. Этот указатель также указывает на первый элемент массива, но информация о типе отличается.  

7)Выделение памяти в куче  

Память, которую используют программы, состоит из нескольких частей — сегментов:  

+ **Сегмент кода** (или «текстовый сегмент»), где находится скомпилированная программа. Обычно доступен только для чтения.  

+ **Сегмент bss** (или «неинициализированный сегмент данных»), где хранятся глобальные и статические переменные, инициализированные нулем.  

+ **Сегмент данных** (или «сегмент инициализированных данных»), где хранятся инициализированные глобальные и статические переменные.  

+ **Куча**, откуда выделяются динамические переменные.  

+ **Стек вызовов**, где хранятся параметры функции, локальные переменные и другая информация, связанная с функциями  

Сегмент кучи (или просто «куча») отслеживает память, используемую для динамического выделения. Мы уже немного поговорили о куче на уроке о динамическом выделении памяти. В языке C++ при использовании оператора new динамическая память выделяется из сегмента кучи самой программы:  

     int *ptr = new int; // для ptr выделяется 4 байта из кучи 
     int *array = new int[10]; // для array выделяется 40 байт из кучи  

Куча имеет свои преимущества и недостатки:  

+ Выделение памяти в куче сравнительно медленное.  

+ Выделенная память остается выделенной до тех пор, пока не будет освобождена (остерегайтесь утечек памяти) или пока программа не завершит свое выполнение.  

+ Доступ к динамически выделенной памяти осуществляется только через указатель. Разыменование указателя происходит медленнее, чем доступ к переменной напрямую.  

+ Поскольку куча представляет собой большой резервуар памяти, то именно она используется для выделения больших массивов, структур или классов.  

8)Операторы __*new и delete*__ встроенные динамические массивы  

Операторы new и delete используются для динамического выделения памяти для указателя, переменной или массива и освобождения этой памяти. Хотя подобное случается крайне редко, оператор new может потерпеть крах, если в операционной системе не останется свободной памяти, поэтому не забывайте выполнять проверку того, возвращает ли оператор new нулевой указатель.  

Обязательно используйте оператор delete[] для удаления динамически выделенного массива. Указатели, указывающие на освобожденную память, называются висячими указателями. Разыменование висячего указателя не приведет ни к чему хорошему.  

Невозможность удалить динамически выделенную память приведет к утечке памяти, когда указатель, указывающий на эту память, выйдет из области видимости.  

В C++ отсутствует тип «динамический массив». Имеются только операторы для создания и удаления динамического массива, доступ к нему осуществляется через указатели на начало массива (своего рода полное сведение). Размер такого массива надо хранить отдельно. Динамические массивы желательно инкапсулировать в C++ классы.  

При работе с динамическим массивом также следует учитывать, что его размер можно изменять при помощи оператора new и delete

9)Проблемы освобождения памяти  

+ **Утечка памяти: Если память, выделенная для динамического массива, не освобождается после использования, это приводит к утечке памяти. В результате у программы может закончиться доступная память, что может привести к некорректной работе программы или даже к ее сбою.

+ Двойное освобождение памяти: Если память для динамического массива освобождается дважды, это приводит к ошибке. При попытке освободить уже освобожденный блок памяти возникает неопределенное поведение программы или сбой.

+ Неправильное использование оператора delete или delete[]: В C++ для освобождения памяти, выделенной для динамического массива, используется оператор delete[]. Если вместо него используется оператор delete, то поведение программы будет неопределенным и может привести к ошибкам.

10)Связь встроенных массивов и указателей  

Имя массива - указатель на первый элемент  

Указатель, указывающий на освобожденную память, называется **висячим указателем**. Разыменование или удаление висячего указателя приведет к неожиданным результатам.  

Во-первых, старайтесь избегать ситуаций, когда несколько указателей указывают на одну и ту же часть выделенной памяти. Если это невозможно, то выясните, какой указатель из всех «владеет» памятью (и отвечает за её удаление), а какие указатели просто получают доступ к ней.  

Во-вторых, когда вы удаляете указатель, и, если он не выходит из области видимости сразу же после удаления, то его нужно сделать нулевым, т.е. присвоить значение 0 (или nullptr в С++11). Под "выходом из области видимости сразу же после удаления" имеется в виду, что вы удаляете указатель в самом конце блока, в котором он объявлен.  

**Правило: Присваивайте удаленным указателям значение 0 (или nullptr в C++11), если они не выходят из области видимости сразу же после удаления.**  

11)Арифметика указателей  

При вычислении результата выражения адресной арифметики (или "арифметики с указателями") компилятор всегда умножает целочисленный операнд на размер объекта, на который указывает указатель. Например:  

    #include <iostream>  
    int main()
    { 
    int value = 8; 
    int *ptr = &value; 
     
    std::cout << ptr << '\n'; 
    std::cout << ptr+1 << '\n'; 
    std::cout << ptr+2 << '\n'; 
    std::cout << ptr+3 << '\n'; 
     
    return 0; 
     } 

Результат на моем компьютере:  
002CF9A4  
002CF9A8  
002CF9AC  
002CF9B0  

Как вы можете видеть, каждый последующий адрес увеличивается на 4. Это связано с тем, что размер типа int на моем компьютере составляет 4 байта.Та же программа, но с использованием типа short вместо типа int:  

    #include <iostream> 
     
    int main() 
    { 
    short value = 8; 
    short *ptr = &value; 
     
    std::cout << ptr << '\n'; 
    std::cout << ptr+1 << '\n'; 
    std::cout << ptr+2 << '\n'; 
    std::cout << ptr+3 << '\n'; 
     
    return 0; 
    }  
Результат:  
002BFA20  
002BFA22  
002BFA24  
002BFA26  

Поскольку тип short занимает 2 байта, то каждый следующий адрес больше предыдущего на 2.  

# Сдача плюсов  

## Память  

1)Адреса и указатели  

+ **Адрес:** Адрес представляет собой числовое значение, которое идентифицирует положение в памяти компьютера. В C++ вы можете получить адрес переменной с помощью оператора "адрес" (&).  

+ **Указатель:** Указатель - это переменная, которая хранит адрес другой переменной. Указатели в C++ объявляются с помощью символа "*", перед именем переменной.  

+ **Работа с указателями:** Указатели позволяют изменять значения переменных по их адресам. Для этого можно использовать оператор разыменования "*"  

    int number = 10;
    int* ptr = &number;
    *ptr = 20;  

+ **Передача данных по указателю:** Один из основных сценариев использования указателей - передача данных в функцию по указателю. Это используется для того, чтобы функция могла изменить значения переданных ей переменных.  

    void increment(int* ptr) {
        (*ptr)++;
    }

    int main() {
        int number = 10;
        increment(&number);
        // значение переменной number увеличится на 1
        return 0;
    }  

### При работе с указателями в C++ возникают следующие опасности  

+ Некорректные указатели: использование непроинициализированного указателя или указателя, указывающего на удаленную память, может привести к неопределенному поведению программы или краху. От этой опасности можно избавиться, инициализируя указатели перед использованием и проверяя их на нулевое значение перед осуществлением доступа.  

+ Утечка памяти: неверное освобождение памяти, на которую указывает указатель, может привести к утечке памяти. То есть, после использования этой памяти она не будет автоматически освобождена, что может привести к исчерпанию ресурсов системы. Для избежания утечек памяти следует следить за освобождением памяти, выделенной с помощью оператора new, при помощи оператора delete.  

+ Данное использование указателей: некорректное обращение к памяти по указателю может привести к перезаписи данных, которые хранятся в других областях памяти, или краху программы. Чтобы избежать этой опасности, необходимо корректно использовать указатели, следить за доступом к памяти и правильно управлять ее выделением и освобождением.  

+ Неопределенное поведение: использование указателей, не соответствующих типу данных или выходящих за пределы массива, приводит к неопределенному поведению программы. Например, это может вызвать ошибки сегментации или перезапись данных других переменных. Чтобы избежать этой опасности, следует правильно объявлять и использовать указатели, а также выполнять проверки и контролировать доступ к памяти.  

### Для избежания указанных опасностей рекомендуется использовать следующие методы:  

+ Использование ссылок вместо указателей, когда это возможно.  

+ Использование умных указателей, таких как std::unique_ptr, std::shared_ptr и std::weak_ptr, которые автоматически управляют выделенной памятью и предотвращают утечку памяти.  
+ Использование операторов new и delete с учетом необходимого выделения и освобождения памяти.  

+ Проверка указателей на нулевое значение перед осуществлением доступа к памяти.  

+ Использование стандартных функций и структур данных, которые обеспечивают безопасное использование указателей, таких как std::deque или std::vector вместо C-стиля массивов.  

2)_nullptr_ _void*_  

**nullptr** - это ключевое слово, которое представляет нулевое значение для указателей. Оно позволяет явно указывать на то, что указатель не указывает на какой-либо объект или переменную. Ранее в C++ для обозначения нулевых указателей использовался NULL, однако nullptr представляет более безопасный и строгий подход к работе с указателями.  

**_void*_** - это тип указателя на неопределенные данные. То есть, указатель типа **_void*_** может указывать на объект любого типа данных. Однако нельзя разыменовать указатель типа void*, поскольку компилятор не знает, какой именно тип данных содержится по этому адресу. Для работы с указателем типа void* его необходимо привести к конкретному типу, чтобы использовать его значения или изменить данные по этому адресу.  

Обычно nullptr используется для явного указания нулевых указателей, а void* используется, когда необходимо работать с указателями на неопределенные типы данных или в ситуациях, когда тип данных не важен или может различаться.  

3)Сегменты адресного пространства процесса  

+ Сегмент кода (Code Segment):  
Этот сегмент содержит исполняемый код программы, то есть инструкции, которые выполняются процессором. Он доступен только для чтения и выполнения, и он обычно размещается в начале адресного пространства процесса.  

+ Сегмент данных (Data Segment):  
Этот сегмент предназначен для хранения статических или глобальных переменных, которые используются в программе. Он может быть подразделен на две части: сегмент инициализированных данных и сегмент неинициализированных данных (также известный как "BSS" или "Block Started by Symbol"). Сегмент инициализированных данных содержит переменные, которые имеют явно заданные значения, в то время как сегмент неинициализированных данных содержит переменные, которые не имеют явно заданных значений и инициализируются значением по умолчанию (например, нулевым).  

+ Сегмент стека (Stack Segment):
Сегмент стека используется для хранения локальных переменных и вызовов функций в процессе выполнения программы. Он работает по принципу "последний вошел, первый вышел" (LIFO - Last In, First Out), сохраняя информацию о вызовах функций и возвращении из них. Каждый поток выполнения программы обычно имеет свой собственный сегмент стека.

+ Сегмент кучи (Heap Segment):  
Сегмент кучи используется для динамического выделения памяти во время выполнения программы, используя операторы new и delete (или malloc и free в C). В этом сегменте хранятся данные, которые создаются и уничтожаются в процессе выполнения программы по мере необходимости.  

+ Сегмент сегментированных памяти (Segmented Memory Segment):  
Этот сегмент хранит информацию о сегментированной памяти, которая используется в некоторых операционных системах для организации адресного пространства процесса в несколько фрагментов с различными правами доступа. В современных операционных системах сегментацию обычно заменяют плоской моделью памяти.  

4)Глобальные и локальные переменные  

Глобальные переменные объявляются вне всех функций и классов, можно сказать, что они доступны везде в программе. Обычно их объявляют в начале программы и их значение сохраняется до конца программы. Глобальные переменные могут быть использованы в любой функции или классе.  

Локальные переменные объявляются внутри функций или блоков кода и доступны только внутри этого блока. Они существуют только во время выполнения этой функции или блока кода. Локальные переменные могут иметь одно и то же имя, что и глобальные переменные, но будут считаться отдельными переменными. Это объясняется тем, что локальные переменные имеют более высокий приоритет использования, чем глобальные переменные.  

Отличие локальных переменных от глобальных заключается в области видимости. Глобальные переменные видны во всех функциях программы, а локальные переменные видны только внутри функции или блока кода, в котором они объявлены.  

Одна из особенностей локальных переменных заключается в том, что при каждом вызове функции или блока кода создается новая локальная переменная с тем же именем, и после выполнения функции или блока кода эта переменная уничтожается.  

Глобальные переменные могут быть использованы для хранения данных, доступных для всех функций или классов программы, а локальные переменные создаются и используются для временного хранения данных, которые нужны только внутри функции или блока кода.  

### Использование глобальных переменных может привести к следующим проблемам  

+ Запутанность и непредсказуемость кода: Если переменная может быть изменена из разных мест, это может сделать код сложным для понимания и отладки.

+ Конфликты имен переменных: Если в разных частях программы используется глобальная переменная с одинаковым именем, это может привести к ошибкам в результате неожиданного взаимодействия.

+ Зависимость кода: Использование глобальных переменных может привести к тому, что разные части кода станут сильно связанными, что затруднит их тестирование и обновление.

+ Усложнение многопоточности: Если несколько потоков программы могут одновременно изменять глобальные переменные, это может привести к ошибкам синхронизации и неправильному поведению программы.

### Для исправления этих проблем можно использовать следующие подходы

+ Используйте локальные переменные в функциях и классах, которые ограничены областью видимости и доступны только внутри конкретного блока кода.

+ Передавайте переменные в функции и методы в качестве параметров, чтобы изолировать их изменение и упростить код.

+ Используйте объекты и классы, чтобы инкапсулировать состояние и поведение, вместо глобальных переменных.

+ Разделите код на модули или компоненты, чтобы сократить взаимодействие между глобальными переменными разных частей программы.

+ Используйте принципы объектно-ориентированного программирования, такие как наследование и полиморфизм, чтобы сделать код более гибким и изолированным от глобальных переменных.

+ Используйте синхронизацию и мьютексы при работе с глобальными переменными в многопоточной среде, чтобы избежать ошибок синхронизации и состояний гонки.

5)Встроенные статические массивы

**Массив** — совокупный тип данных, который позволяет получить доступ ко всем переменным одного и того же типа данных через использование одного идентификатора  

**Статический массив** – это массив, который объявлен с фиксированным размером в момент компиляции программы. Размер массива определяется в квадратных скобках при его объявлении.  

+ Доступ к элементам массива осуществляется через индексатор, значения индекса от 0 до N-1  
+ Выход за границы массива не контролируется, ошибка может привести к неопределенному поведению.  
+ T a[size] - массив элементов типа T размером size, где size должен быть константным выражением приводимым к типу size_t(Константное выражение — выражение, известное во время компиляции)  

Если массив объявлен статически, то есть в глобальной области видимости, в области видимости пространства имен или в качестве статического члена класса, то он размещается в статической памяти. Массивам, объявленным локально, память выделяется на стеке. (Естественно, надо учитывать ограниченный размер стека при выборе размера локальных массивов.) Нестатические члены класса размещаются в границах экземпляра класса.  

+ Нельзя объявить массив, элементы которого имеют тип void.  
+ Нельзя объявить массив ссылок.(Вместо этого можно использовать массив константных указателей)  
+ Нельзя объявить массив функций.(Вместо этого можно использовать массив указателей на функцию.)  

Статический массив имеет фиксированный размер, поэтому вы не можете добавлять или удалять элементы из него после его создания. Вы можете изменять значения элементов, но не размер массива.  

6)Указатели и ссылки на статический массив  

Распространенная ошибка думать, что переменная array и указатель на array являются одним и тем же объектом. Это не так. Хотя оба указывают на первый  элемент массива, информация о типе данных у них разная. В вышеприведенном примере типом переменной array является int[4], тогда как типом указателя на массив является int *.  

Путаница вызвана тем, что во многих случаях, при вычислении, фиксированный массив распадается (неявно преобразовывается) в указатель на первый элемент массива. Доступ к элементам по-прежнему осуществляется через указатель, но информация, полученная из типа массива (например, его размер), не может быть доступна из типа указателя  

При использовании в фиксированном массиве, оператор sizeof возвращает размер всего массива (длина массива * размер элемента). При использовании с указателем, оператор sizeof возвращает размер адреса памяти (в 
байтах). Например:  

    #include <iostream> 
    
    int main() 
    { 
    int array[4] = { 5, 8, 6, 4 }; 
     
    std::cout << sizeof(array) << '\n'; // выведется sizeof(int) * длина array 16
     
    int *ptr = array; 
    std::cout << sizeof(ptr) << '\n'; // выведется размер указателя 4
     
    return 0; 
    }  

Второе различие возникает при использовании оператора адреса &. Используя адрес указателя, мы получаем адрес памяти переменной указателя. Используя адрес массива, возвращается указатель на целый массив. Этот указатель также указывает на первый элемент массива, но информация о типе отличается.  

+ При передаче массива в качестве аргумента в функцию, массив распадается в указатель на массив и этот указатель передается в функцию  
+ 

7)Выделение памяти в куче  
8)Операторы __*new*__ и __*delete*__ встроенные динамические массивы  
9)Проблемы освобождения памяти  
10)Связь встроенных массивов и указателей  
11)Арифметика указателей  

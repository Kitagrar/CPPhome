# Сдача плюсов  

## Проектирования классов  

1)Перегрузка операторов.  

Есть три разных способа перегрузки операторов:  

+ через дружественные функции;  

объявили дружественную функцию operator+();  
задали в качестве параметров два операнда, с которыми хотим работать —два объекта класса Dollars;  
записали реализацию операции сложения.  

+ через обычные функции;  
+ через методы класса.  

2)Перегрузка оператора[].  

Оператор индексации является одним из операторов, перегрузка которого должна выполняться через метод класса. Функция перегрузки оператора [] всегда будет принимать один параметр: значение индекса (элемент массива, к которому требуется доступ).  

    #include <iostream> 
    
    class IntArray 
    { 
    private: 
    int m_array[10]; 

    public: 
    int& operator[] (const int index); 
    }; 

    int& IntArray::operator[] (const int index) 
    { 
    return m_array[index]; 
    }

    int main() 
    { 
    IntArray array; 
    array[4] = 5; // присваиваем значение 
    std::cout << array[4]; // выводим значение 

    return 0; 
    }  

**Почему оператор индексации [] использует возврат по ссылке?**  

Рассмотрим детально, как обрабатывается стейтмент array[4] = 5. Поскольку приоритет оператора индексации выше приоритета оператора присваивания, то сначала выполняется часть array[4]. array[4] приводит к вызову функции перегрузки оператора [], которая возвратит array.m_array[4]. Поскольку оператор [] использует возврат по ссылке, то он возвращает фактический элемент array.m_array[4]. Наше частично обработанное выражение становится array.m_array[4] = 5, что является прямой операцией присваивания значения элементу массива.  

3)Перегрузка оператора <<.  

Перегрузка оператора вывода << аналогична перегрузке оператора + (оба являются бинарными операторами), за исключением того, что их типы различны.  

Рассмотрим выражение std::cout << point. Если оператором является <<, то чем тогда являются операнды? Левым операндом является объект std::cout, а правым — объект нашего класса Point. std::cout фактически является объектом типа std::ostream, поэтому перегрузка оператора << выглядит следующим образом:  

    std::cout - это объект std::ostream 
    friend std::ostream& operator<< (std::ostream &out, const Point &point); 

4)Оператор приведения.  

Перегрузка оператора () используется в реализации функторов (или "функциональных объектов") — классы, которые работают как функции. Преимущество функтора над обычной функцией заключается в том, что функторы могут хранить данные в переменных-членах (поскольку они сами являются классами).  

+ Во-первых, перегрузка круглых скобок должна осуществляться через метод класса.  

+ Во-вторых, в не объектно-ориентированном С++ оператор () является оператором вызова функции. В случае с классами перегрузка круглых скобок выполняется в методе operator()(){} (в объявлении функции перегрузки находятся две пары круглых скобок).  

Перегрузка оператора () с двумя параметрами используется для получения доступа к двумерным массивам или для возврата подмножеств одномерного массива (два параметра будут конкретизировать условия отбора элементов подмножества). Всё остальное лучше реализовать через отдельные методы с более информативными названиями, нежели через перегрузку оператора ().  

5)Преобразующий конструктор.  

Конструкторы, которые используются в неявных преобразованиях, называются конструкторами преобразования (или "конструкторами конвертации")  

6)explicit конструктор.  

    #include <iostream> 
    #include <string> 

    class SomeString 
    { 
    private: 
    std::string m_string; 
    public: 
    SomeString(int a) // выделяем строку размером a 
    { 
    m_string.resize(a); 
    1} 

    SomeString(const char *string) // выделяем строку для хранения значениятипа string 
    { 
    m_string = string; 
    } 

    friend std::ostream& operator<<(std::ostream& out, const SomeString &s); 

    };

    std::ostream& operator<<(std::ostream& out, const SomeString &s) 
    { 
    out << s.m_string; 
    return out; 
    } 

    int main() 
    { 
    SomeString mystring = 'a'; // выполняется копирующая инициализация 
    std::cout << mystring; 
    return 0; 
    }  

В примере, приведенном выше, мы пытаемся инициализировать строку одним символом типа char. Поскольку переменные типа char являются частью семейства целочисленных типов, то компилятор будет использовать конструктор преобразования SomeString(int) для неявного преобразования символа типа char в тип SomeString.  

Один из способов решения этой проблемы — сделать конструктор явным, используя ключевое слово explicit (которое пишется перед именем конструктора). Явные конструкторы (с ключевым словом explicit) не используются для неявных конвертаций  

 **Для предотвращения возникновения ошибок с неявными конвертациями делайте ваши конструкторы явными, используя ключевое слово explicit.**  

7)Классификация выражений.  

![Alt text](../images/cc)  

**Выражения категории rvalue обладают следующими свойствами:**

+ нельзя получить адрес rvalue в памяти – это напрямую следует из свойства отсутствия идентичности;
+ не могут находиться в левой части оператора присваивания или составного присваивания;
+ могут использоваться для инициализации константной lvalue-ссылки или rvalue-ссылки, при этом время жизни объекта расширяется до времени жизни ссылки;
+ если используются как аргумент при вызове функции, у которой есть 2 перегруженные версии: одна принимает константную lvalue-ссылку, а другая – rvalue-ссылку, то выбирается версия, принимающая rvalue-ссылку. Именно это свойство используется при реализации семантики перемещения (move semantics)  

**Выражения категории lvalue обладают следующими свойствами:**  

+ могут быть неявно преобразованы в prvalue;  
+ могут быть полиморфными, т. е. для них имеют смысл понятия статического и динамического типа;  
+ не могут иметь тип void – это напрямую следует из свойства наличия идентичности, ведь для выражений типа void нет такого + + + параметра, который позволил бы отличать их одно от другого;  
+ могут иметь неполный тип (incomplete typможно взять адрес (используя встроенный унарный оператор &);  
+ модифицируемые lvalue могут находиться в левой части оператора присваивания или составных операторов присваивания;  
+ могут использоваться для инициализации ссылки на lvalue (как константной, так и неконстантной).  

К категории lvalue относятся следующие выражения:  

имя переменной, функции или поле класса любого типа. Даже если переменная является rvalue-ссылкой, имя этой переменной в выражении является lvalue;  

8)rvalue и lvalue ссылки.  

lvalue ссылка — обычная ссылка, с которой мы уже имели дело ранее  

+ `T&` — может быть инициализирована любым не **const  && lvalue выражением**  
+ `const T&` — может быть инициализирована любым выражением (const/не+const , rvalue, lvalue) . Продлевает время жизни связанного объекта до времени жизни ссылки  
rvalue+ссылка  
+ `T&&` — может быть инициализирована не+const rvalue выражением. Продлевает время жизни, связанного объекта до времени жизни сслыки  
+ `const T&&` — любые выражения кроме lvalue (бесполезна)  

![Alt text](../images/Untitled.png)  

9)Копирование и перемещение.  

В C++ копирование и перемещение объектов между классами осуществляется с помощью конструктора копирования и конструктора перемещения.  
Внутри конструктора копирования можно копировать значения полей другого объекта в поля создаваемого объекта.  
Внутри конструктора перемещения можно переместить значения полей другого объекта в поля создаваемого объекта и освободить ресурсы в исходном объекте, чтобы избежать двойного освобождения памяти или других ресурсов.  
Оператор присваивания копированием и оператор присваивания перемещением могут быть определены аналогично конструктору копирования и конструктору перемещения.  

Зачем нужны две разные семантики: копирующая и перемещающая на примере массива  

`T x = y`  

+ для встроенных типов выполняется комирование  
+ для сложныйх типов может выполняться как копирование, так и перемещение (начиная с С++11)  
+ Копирование — операнды становятся эквивалентными и независимыми  
+ Перемещение — правый операнд “облуляется”, левый операнд получает все ресурсы правого  

    T func()
    {
            T x;
            return x; // зачем копировать, если он нам больше не нужен  
    }  

    void swap(X& a, X& b) // много лишних копирований
    {
        const X tmp = a;
        a = b;
        b = tmp
    }  

Тут логично было бы выполнить перемещение …  

### Как выполнять перемещение

Есть специальные, перемещающие операторы, которые выполняют всю работу по перемещению  

`operator=(...)` : куда = откуда  

Но как компилятору понять, когда нужно выполнять копирование, а когда перемещение  

💡 Компилятор выбирает между перемещением и копированием на основании категории выражения, стоящего справа  

Если справа стоит выражение, которым можно проиницилизировать `T&&`, то выполняется перемещение  
Если справа стоит выражение, которым можно проинициализировать `const T&` , то выполняется копирование  

**Но как тогда перемещать lvalue выражения?**  

Нужно прикастить наш объекта к rvalue-ссылке c помощью `std::move()`  

💡 `std::move` выполняет только приведение типа, само перемещение выполняет `operator=` , правильная перегрузка которого выбирается на основании категории выражения  

10)Перемещающие специальные функции.  

+ **Конструктор перемещения (Move constructor):** это специальная функция, которая создает новый объект за счет перемещения ресурсов из другого объекта. Она имеет синтаксис: X::X(X&& other).  

+ **Оператор перемещающего присваивания (Move assignment operator):** это специальная функция, которая перемещает ресурсы из одного объекта в другой. Она имеет синтаксис: X& operator=(X&& other).  

+ **Деструктор перемещения (Move destructor):** это специальная функция, которая освобождает ресурсы, которые были захвачены объектом. Она вызывается, когда объект выходит из области видимости или уничтожается. Синтаксис: ~X() noexcept.  

11)Правила генерации специальных функций членов.  

Если вам пришлось реализовать хотя бы одну спец.функцию, не считая конструктора по умолчанию, то реализовывайте все спец.функции сами  

12)Поверхностное и глубокое копирование.  

При работе копирующего конструктора используется инициализация класса путем создании копии объекта. Предоставляемые компилятором функции выполняют поверхностное копирование, что может вызывать проблемы у классов, которые работают с динамически выделенной памятью  

Это означает, что C++ выполняет копирование для каждого члена класса индивидуально (используя оператор присваивания по умолчанию вместо перегрузки оператора присваивания и прямую инициализацию вместо конструктора копирования).  

Одним из решений этой проблемы является выполнение глубокого копирования. При глубоком копировании память сначала выделяется для копирования адреса, который содержит исходный указатель, а затем для копирования фактического значения. Таким образом копия находится в отдельной, от исходного значения, памяти и они никак не влияют друг на друга  

13)std::move  

Функция std::move() — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. Мы можем передать l-value в функцию std::move(), и std::move() вернет нам ссылку r-value. Для работы с std::move() нужно подключить заголовочный файл utility  

+ Мы также можем использовать std::move() для заполнения контейнерных классов (таких как std::vector) значениями l-values.  
+ Функция std::move() также может быть полезна при перемещении содержимого из одного умного указателя в другой  
+ Функция std::move() также может быть полезна при сортировке элементов массива.  

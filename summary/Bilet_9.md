# Сдача плюсов  

## Шаблоны функций  

1)Обобщенное программирование.  

Для реализации обобщенного программирования в C++ используется механизм шаблонов. Шаблон позволяет задать общую структуру алгоритма или контейнера, а затем параметризовать этот шаблон типом данных, с которым будет работать.  

Слово Template («шаблон») позволяет понять, как именно данная языковая возможность работает под капотом. Реализованная функция служит просто шаблоном для компилятора, который генерирует новые функции для шаблона любого типа, какой применяется с этим компилятором.  

2)Инстанцирование шаблона.  

Шаблон инстанцируется только если он использован  

Инстанцирование шаблона может происходить двумя способами: явным и неявным.  

**Явное инстанцирование шаблонов C++** Явное инстанцирование возможно только для шаблонов классов. Оно происходит путем указания конкретных аргументов шаблона при создании объекта класса.  
При явном инстанцировании компилятор создает отдельные экземпляры класса для каждого указанного типа данных.

**Неявное инстанцирование шаблонов C++** Неявное инстанцирование происходит автоматически при вызове шаблонной функции или при создании объекта шаблонного класса без указания типа данных.  

3)Двухэтапная трансляция шаблона.  

В первой стадии компиляции компилятор анализирует код шаблона, проверяет его синтаксическую и семантическую корректность, но не генерирует объектный код для шаблона.  

На второй стадии, во время инстанциации, компилятор использует сохраненную информацию о шаблоне, чтобы сгенерировать код для конкретной комбинации типов, переданных в качестве аргументов.  

Из-за двухэтапной трансляции нельзя разделять объявление и определение  

4)Шаблоны функций.  

В языке C++ **шаблоны функций** — это функции, которые служат образцом для создания других подобных функций. Главная идея — создание функций без указания точного типа(ов) некоторых или всех переменных. Для этого мы определяем функцию, указывая тип параметра шаблона, который используется вместо любого типа данных.  

Чтобы всё заработало, нам нужно сообщить компилятору две вещи:  

+ Определение шаблона функции.  
+ Указание того, что Т является типом параметра шаблона функции.  

Мы можем сделать это в одной строке кода, выполнив объявление шаблона (а точнее — объявление параметров шаблона):  

    template <typename T> // объявление параметра шаблона функции 
    T max(T a, T b) 
    { 
    return (a > b) ? a : b; 
    }  

5)Шаблоны методов.  

Шаблон метода класса:  

    template <typename T>
    class MyClass {
    public:
        void myMethod(T parameter) {
            // Реализация метода
        }
    };  

Шаблон метода функции:  

    template <typename T>
    void myFunction(T parameter) {
        // Реализация функции
    }  

6)Шаблоны классов.  

Шаблоны классов работают точно так же, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы параметров шаблона класса на фактические (передаваемые) типы данных, а затем компилирует эту копию. Если у вас есть шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать.  

7)Полная и частичная специализация шаблона.  

При полной специализации шаблона указываются значения для всех параметров шаблона. И тогда для указанного набора аргументов (типов) компилятор будет использовать специализацию шаблона, а не создавать класс на основе шаблона.  

Частичная специализация шаблонов позволяет определить версии шаблона для определенных шаблонных параметров. Она используется, когда нужно особо настроить шаблон для широкого диапазона типов. Частичная специализация создает более узкий шаблон, который будет использоваться, когда определенные условия типов выполнены.  

8)Прокси класс.  

Прокси-класс в C++ - это класс, который предоставляет доступ к другому объекту через интерфейс, идентичный интерфейсу этого объекта. Он позволяет контролировать доступ к оригинальному объекту, добавлять дополнительную функциональность или выполнять какую-либо логику до или после вызова методов оригинального объекта.  

9)Значения параметра шаблона по умолчанию.  

В C++, значения параметров шаблона по умолчанию могут быть определены для функций и классов шаблонов. Значения параметров по умолчанию позволяют вызывать шаблоны без явного указания конкретных аргументов.  

Пример параметров со значениями по умолчанию для функции-шаблона:  

    template <typename T = int, int N = 5>
    void printArray(T arr[N]) {
        for (int i = 0; i < N; i++) {
            cout << arr[i] << " ";
        }
        cout << endl;
    }  

В этом примере шаблонная функция `printArray` принимает массив типа `T` и размер `N`. По умолчанию, если аргументы не указаны явно при вызове функции-шаблона, тип `T` будет `int`, а размер массива `N` будет `5`.  

10)Нетиповые параметры шаблонов.  

Не типовые параметры шаблонов могут быть целочисленными или перечисляемыми типами и используются для передачи значений или констант в шаблон.  

11)Шаблоны псевдонимов.  

Шаблон псевдонима — это шаблон, который, будучи специализированным, эквивалентен результату подстановки аргументов шаблона шаблона псевдонима на параметры шаблона  

+ Шаблоны псевдонимов никогда не выводятся путем выведения аргумента шаблона при выводе параметра шаблона шаблона.  
+ Невозможно частично или явно специализировать шаблон псевдонима.  
+ Как и любое объявление шаблона, шаблон псевдонима может быть объявлен только в области класса или пространства имен.  

12)Шаблоны переменных  

Переменная, экземпляр которой создается из шаблона переменной, называется инстанцированной переменной. Статический элемент данных, созданный из шаблона статического элемента данных, называется экземпляром статического элемента данных.  

Шаблон переменной может быть введен объявлением шаблона в области видимости пространства имен, где variable-declaration объявляет переменную.  

# Сдача плюсов  

## Классы  

1)Три столпа ООП.  

+ **Инкапсуляция** — слияние приватных данных и публичных методов  
+ **Полиморфизм** — разные реализации в одинаковом интерфейсе (Пример: перегрузка функций)  
+ **Наследование — передача каких-то свойств от родителя к потомку**  
+ **Абстракция** — стоит отдельно. Представление реальных сущностей в виде абстракций в коде  

2)Инвариант класса  

**Инвариант класса (или инвариант типа)** — инвариант, используемый для ограничения объектов класса. Методы класса должны сохранять инвариант.  

Во время создания классов устанавливаются их инварианты, которые постоянно поддерживаются между вызовами публичных методов. Временное нарушение классовой инвариантности между частными вызовами метода возможно, хотя и нежелательно.  

Инвариант объекта представляет собой конструкцию программирования, состоящую из набора инвариантных свойств. Это гарантирует, что объект всегда будет соответствовать предопределенным условиям, и поэтому методы могут всегда ссылаться на объект без риска сделать неточные презумпции.  

2)Интерфейс и реализация.  

**Интерфейс (или «интерфейсный класс»)** — это класс без переменных-членов, все методы которого являются чистыми виртуальными функциями. Имена интерфейсов часто начинаются с I.  

Разделение класса на интерфейс и реализацию в C++ позволяет создавать абстрактные классы, которые определяют только интерфейс и не содержат реализации. Реализацию абстрактного класса можно определить отдельно. Это позволяет программистам разрабатывать более гибкое и модульное программное обеспечение.  

**Абстрактный класс** - это класс, который содержит как абстрактные методы (чисто виртуальные методы), так и конкретные методы с реализацией. Абстрактные методы не имеют определения в абстрактном классе, они лишь объявлены, чтобы указать, что все подклассы должны их реализовать.

3)Инкапсуляция.  

В объектно-ориентированном программировании инкапсуляция (или "сокрытие информации") — это процесс скрытого хранения деталей реализации объекта. Пользователи обращаются к объекту через открытый интерфейс.  

В языке C++ инкапсуляция реализована через спецификаторы доступа.  

4)Геттеры и сеттеры.  

Функции доступа обычно бывают двух типов:  

+ геттеры — это функции, которые возвращают значения закрытых переменных-членов класса;  

**Геттеры должны использовать тип возврата по значению или по константной ссылке.**

+ сеттеры — это функции, которые позволяют присваивать значения закрытым переменным-членам класса  

**Предоставляйте функции доступа только в том случае, когда нужно, чтобы пользователь имел возможность получать или присваивать значения членам класса.**  

5)Секции класса.  

Секция доступа к членам класса: эта секция определяет уровень доступа к членам класса. В C++ их может быть три типа: public, private и protected. Секция доступа задает область видимости методов и переменных класса.  

Секция данных класса: в этой секции определяются переменные-члены класса, которые хранят данные для определенных объектов класса.  

Секция функций-членов класса: в этой секции определяются методы, которые могут быть вызваны для объектов класса. Методы определяют поведение класса.  

Секция конструкторов и деструкторов: эта секция определяет конструкторы и деструкторы класса.  

Секция статических членов класса: в этой секции определяются статические переменные-члены класса и статические методы-члены класса.  

6)Инициализация полей класса.  

+ Инициализация полей класса в конструкторах  
+ Инициализация полей класса с помощью классных объектов  
+ Инициализация полей класса через списки инициализации  

7)Специальные функции + члены класса.  

+ Констурктор по умолчанию  
+ Конструктор преобразования  
+ Копирующий конструктор  
+ Оператор копирования  
+ Перемещающий конструктор  
+ Оператор перемещения  
+ Деструктор  

8)this.  

При компиляции обычного метода, компилятор неявно добавляет к нему параметр `*this`. Указатель `*this` — это скрытый константный указатель, содержащий адрес объекта, который вызывает метод класса.  

**Указатель *this всегда указывает на текущий объект**  

В большинстве случаев вам не нужно явно указывать указатель *this. Тем не менее, иногда это может быть полезным. Например, если у вас есть конструктор (или метод), который имеет параметр с тем же именем, что и переменная-член, то устранить неоднозначность можно с помощью указателя `*this`  

9)Этапы работы конструктора и деструктора.  

См. Bilet_4 (3)  

10)Статические поля класса.  

**Статическое поле класса в C++** - это поле, которое существует в единственном экземпляре на все объекты данного класса. Оно является общим для всех объектов класса и может быть использовано без создания экземпляра класса.  

Статические поля класса полезны, когда требуется сохранить информацию, которая должна быть общая для всех объектов данного класса. Они могут быть использованы для счетчиков, совместного использования переменных между различными объектами класса и другими сценариями.  

Однако статические поля класса также имеют некоторые ограничения:  

+ Они не могут быть определены или инициализированы внутри тела класса, только объявлены.  
+ Они не наследуются подклассами. Каждый подкласс будет иметь свою собственную версию статического поля.  
+ Они имеют глобальную область видимости, что может привести к возможным конфликтам имен в больших проектах.  

11)Друзья класса. Идиома RAII.  

**Дружественная функция** — это функция, которая имеет доступ к закрытым членам класса, как если бы она сама была членом этого класса. Во всех других отношениях дружественная функция является обычной функцией. Ею может быть, как обычная функция, так и метод другого класса. Для объявления дружественной функции используется ключевое слово friend перед прототипом функции, которую вы хотите сделать дружественной классу. Неважно, объявляете ли вы её в public- или в private зоне класса  

### Свойства дружественных функций  

+ Есть доступ к `private/protected` полям  
+ Следует явно передавать экземпляр (не принадлежит классу)  
+ Можно дружить с несколькими  

>Идиома RAII (Resource Acquisition Is Initialization) представляет собой практику в программировании, при которой управление ресурсами (например, динамически выделенной памятью, файлами, сетевыми подключениями и т. д.) связывается с жизненным циклом объекта. Это позволяет обеспечивать автоматическое управление ресурсами, гарантируя их корректное освобождение при завершении срока действия объекта

Реализация:  

+ Конструкторы  
+ Деструкторы (деструкторы используются для автоматического освобождения ресурсов при уничтожении объекта. Например, деструктор может освободить динамическую память)  
+ Возможно использование функций-членов  

12)Раздельная компиляция.  

Раздельная компиляция (или компиляция по модулям) - это подход к компиляции программ, при котором исходный код разбивается на несколько модулей, каждый из которых компилируется в отдельный объектный файл. Затем объектные файлы собираются в исполняемый файл или библиотеку.  

Раздельная компиляция достигается с помощью использования заголовочных файлов и файлов реализации.  

13)ODR.  

C++ требует, чтобы любая функция была определена не более одного раза – One Definition Rule, ODR. Как только вы определяете функцию с одним и тем же именем и сигнатурой в разных единицах трансляции (файлах .cpp), вы получаете индикацию ошибки на этапе линковки.  

Решение одно – если ваш код использует inline функции, позаботьтесь о том, чтобы компиляция разных единиц трансляции выполнялась так, чтобы поведение этих функций оставалось неизменным.  

14)Внутреннее и внешнее связывание.  

Связывание — это процесс, который используется для конвертации идентификаторов (таких как имена переменных или функций) в адреса.  

Когда символ (переменная или функция) обладает внешней связью, он становится видимым компоновщикам из других файлов, то есть “глобально” видимым, доступным всем единицами трансляции.  

Если у символа есть внутренняя связь, то он будет виден только внутри текущей единицы трансляции. Не путайте видимость с правами доступа, например private. Видимость означает, что компоновщик сможет использовать этот символ только при обработке единицы трансляции, в которой был объявлен символ, а не позже (как в случае символов с внешней связью).  

15)Ошибки линковки.  

+ Несовместимость версий  

+ Неправильное объявление функций  

+ Дублирование функций  

+ Неправильная настройка настроек компилятора  

+ Использование статических или динамических библиотек  

+ Использование несовместимых типов или иерархий классов  

+ Неправильный порядок файлов при линковке  

16)Защита от повторного включения (2 способа)  
См Bilet_3 (9)  
Использование директивы препроцессора "#pragma once"  

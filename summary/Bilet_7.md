# Сдача плюсов  

## Наследование  

1)Иерархии классов.  

**Иерархия** — это диаграмма со связями объектов. Большинство иерархий либо демонстрируют прогрессию с течением времени (386 > 486 > Pentium), либо классифицируют вещи таким образом, чтобы они переходили от общего к конкретному (Фрукты > Яблоки > Макинтош).  

2)Наследование интерфейса и наследование реализации.  

**Наследование** позволяет моделировать отношения типа «является» между двумя объектами. Объект, который наследует, называется дочерним классом. Объект, которого наследуют, называется родительским классом  

**При наследовании дочерний класс наследует все члены родительского класса.**  

В C++ наследование интерфейса осуществляется с помощью использования ключевого слова *class*. В отличие от наследования класса, наследование интерфейса позволяет классу реализовать только методы, определенные в интерфейсе, без необходимости наследования полей и реализации других методов.  

    class Interface {
    public:
        virtual void method1() = 0;
        virtual void method2() = 0;
    };

    class MyClass : public Interface {
    public:
        void method1() override {
            // реализация метода 1
        }

        void method2() override {
            // реализация метода 2
        }
    };  

На уровне реализации, наследование в языке C++ осуществляется с помощью ключевого слова "public". При объявлении класса-наследника, указывается класс-родитель, после которого указывается ключевое слово "public".  

    class Parent {
    public:
        void publicMethod() {
            // implementation
        }
        int publicVariable;
    };

    class Child : public Parent {
        // Child inherits all public methods and variables from Parent
    };  

 К счастью, открытое наследование является самым легким и простым из всех типов. Когда вы открыто наследуете родительский класс, то унаследованные public-члены остаются public, унаследованные protected-членыостаются protected, а унаследованные private-члены остаются недоступными для дочернего класса. Ничего не меняется.  

3)Принцип единственности ответственности.  

Класс должен иметь только одну причину для изменения  

В контексте языка программирования C++ это означает, что каждый класс должен выполнять только одну функцию или иметь только одну ответственность. Это означает, что класс должен иметь только одну основную задачу или функцию, которую он выполняет, и не должен быть перегружен другими не связанными с ним задачами.  

4)Открытое и закрытое наследование.  

**Открытое наследование:** чтобы класс BasketballPlayer унаследовал информацию от класса Human, нам нужно после объявления BasketballPlayer (class BasketballPlayer) использовать двоеточие, ключевое слово **public и имя класса**, от которого мы хотим унаследовать.  

См пункт (3) наследование реализации  

При закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что private-члены остаются недоступными, а protected- иpublic-члены становятся private в дочернем классе.  
**Используйте открытое наследование, если у вас нет веских причин делать иначе**  

5)Динамический полиморфизм.  

С std::variant, доступным с C++17, вы теперь можете использовать безопасные объединения типов и хранить множество разных типов в одном объекте. Вместо указателя на базовый класс хранить все «производные» классы может std::variant.  

    class Derived {
    public:
        void PrintName() const { 
            std::cout << "calling Derived!\n"
        }
    };

    class ExtraDerived {
    public:
        void PrintName() const { 
            std::cout << "calling ExtraDerived!\n"
        }
    };  

    std::variant<Derived, ExtraDerived> var;  

var определяет объект, который может быть Derived или ExtraDerived. По умолчанию он инициализируется значением по умолчанию первой альтернативы.  

6)Виртуальные функции.  

**Виртуальная функция** в языке С++ — это особый тип функции, которая, при её вызове, выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. Это свойство еще известно, как полиморфизм.  

Дочерний метод вызывается тогда, когда совпадает сигнатура (имя, типы параметров и является ли метод константным) и тип возврата дочернего метода с сигнатурой и типом возврата метода родительского класса. Такие методы называются переопределениями  

Чтобы сделать функцию виртуальной, нужно просто указать ключевое слово **virtual** перед объявлением функции.  

Когда в конструкторе вызывается виртуальная функция, она работает только в пределах базовых или создаваемого в данный момент классов. Конструкторы в классах-наследниках ещё не вызывались, и поэтому реализованные в них виртуальные функции не будут вызваны.  

7)Абстрактный базовый класс.  

+ Базовый класс становится абстрактным, если в нем присутствует хотя бы одна чисто виртуальная функция  
+ Виртуальная функция обязана быть переопределенной в в производных классах  
+ Нельзя создать экземпляр абстрактного класса  

Использование чистой виртуальной функции имеет два основных последствия.  

+ Во-первых, любой класс с одной и более чистыми виртуальными функциями становится абстрактным классом, объекты которого создавать нельзя!  
+ Во-вторых, все дочерние классы абстрактного родительского класса должны переопределять все чистые виртуальные функции, в противном случае — они также будут считаться абстрактными классами  

8)Чистая виртуальная функция.  

о C++ позволяет создавать особый вид виртуальных функций, так называемых **чистых виртуальных функций** (или «абстрактных функций»), которые вообще не имеют определения! Переопределяют их дочерние классы.При создании чистой виртуальной функции, вместо определения (написания тела) виртуальной функции, мы просто присваиваем ей значение 0.  

+См пункт (7)  

9)Множественное наследование.  

Множественное наследование позволяет дочернему классу иметь сразу несколько родительских классов. Не рекомендуется использовать множественное наследование, если есть альтернативные решения.  

Большинство таких последствий вызваны неоднозначностью в наследовании.  

10)Алмаз смерти.

Когда класс наследуется от нескольких базовых классов и каждый из них имеет метод с одинаковым названием, то возникает противоречие при вызове этого метода у объекта класса-потомка.  

Ключевое слово virtual помогает разорвать алмаз смерти

11)Виртуальные базовый класс.  

    #include <iostream> 

    class PoweredDevice 
    { 
    public:
    PoweredDevice(int power) 
    { 
    std::cout << "PoweredDevice: " << power << '\n'; 
    } 
    }; 

    class Scanner: virtual public PoweredDevice // примечание: PoweredDevice
    теперь виртуальный базовый класс 
    { 
    public: 
    Scanner(int scanner, int power) 
    : PoweredDevice(power) // эта строка необходима для создания объектов
    класса Scanner, но в этой программе она игнорируется 
    { 
    std::cout << "Scanner: " << scanner << '\n'; 
    } 
    }; 

    class Printer: virtual public PoweredDevice // примечание: PoweredDevice
    теперь виртуальный базовый класс 
    { 
    public: 
    Printer(int printer, int power) 
    : PoweredDevice(power) // эта строка необходима для создания объектов
    класса Printer, но в этой программе она игнорируется 
    { 
    std::cout << "Printer: " << printer << '\n'; 
    } 
    }; 

    class Copier: public Scanner, public Printer 
    { 
    public: 
    Copier(int scanner, int printer, int power) 
    : Scanner(scanner, power), Printer(printer, power), 
    PoweredDevice(power) // построение PoweredDevice выполняется здесь 
    { 
    } 
    }; 

    int main() 
    { 
    Copier copier(1, 2, 3); 
    }  

+ Во-первых, виртуальные базовые классы всегда создаются перед невиртуальными базовыми классами, что обеспечивает построение всех базовых классов до построения их производных классов.  

+ Во-вторых, конструкторы Scanner и Printer по-прежнему вызывают конструктор PoweredDevice. При создании объекта Copier эти вызовы конструктора просто игнорируются, так как именно Copier отвечает за создание PoweredDevice, а не Scanner или Printer. Однако, если бы мы создавали объекты Scanner или Printer, то эти конструкторы вызывались бы и применялись обычные правила наследования.  

+ В-третьих, если класс, становясь дочерним, наследует один или несколько классов, которые, в свою очередь, имеют виртуальные родительские классы, то наиболее дочерний класс отвечает за создание виртуального родительского класса.  

Виртуальный базовый класс — это класс, объект которого является общим для использования всеми дочерними классами.  

12)Перемещение по иерархиям классов вверх и вниз.  

**В C++ для перемещения по иерархиям вниз** и вверх используется ключевое слово virtual и указатели на базовые и производные классы.  

Перемещение вниз осуществляется с помощью приведения типа указателей на базовые классы к указателям на производные классы. Это позволяет получить доступ к методам и свойствам, определенным только в производных классах.  

Перемещение вверх осуществляется с помощью приведения типа указателей на производные классы к указателям на базовые классы. Это ограничивает доступ к методам и свойствам, определенным только в производных классах, и позволяет работать только с методами и свойствами, определенными в базовых классах.  

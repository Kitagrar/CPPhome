# Сдача плюсов  

## Философия языка  

1)**История развития**  

C++ является языком программирования, разработанным в 1983 году Бьёрном Страуструпом на основе языка C. Он стал расширением языка C, добавляя в него объектно-ориентированные возможности и поддержку классов.  

2)**Основные характеристики**  

+ Компилируемый язык программирования, что означает, что исходный код программы должен быть скомпилирован в машинный код перед выполнением.  
+ Поддержка объектно-ориентированного программирования, позволяющая создавать классы и объекты.  
+ Поддержка общих структур данных, таких как массивы и связные списки.  
+ Низкоуровневое программирование, позволяющее написание эффективных системных программ.(но поддерживает и высокоуровневые)  
+ Поддержка шаблонов, что позволяет писать обобщенные алгоритмы.  
+ Поддержка многопоточности: C++ поддерживает многопоточность с помощью стандартной библиотеки или с использованием сторонних библиотек. Это делает его подходящим для разработки параллельных программ и приложений.  

3)**Препроцессор, компилятор, линковщик**  

### Препроцессор  

Препроцессор - это первый шаг в процессе компиляции программы на C++. Он выполняет предварительную обработку исходного кода программы, перед тем как его передать компилятору.  

Препроцессор выполняет следующие задачи:  

+ Обработка директив препроцессора: директивы начинаются с символа "#" и используются, например, для включения заголовочных + файлов или определения макросов.  
+ Включение файлов: препроцессор включает содержимое указанных файлов в исходный код.  
+ Макроопределения: препроцессор заменяет макросы на соответствующий исходный код.  
+ Условная компиляция: препроцессор позволяет компилировать или пропускать части кода в зависимости от определенных условий.  

### Компилятор  

Компилятор - это второй этап процесса компиляции программы на C++. Он принимает препроцессированный исходный код и преобразует его в объектные файлы.  

Компилятор выполняет следующие задачи:  

+ Синтаксический анализ: компилятор анализирует синтаксис исходного кода, чтобы убедиться, что он соответствует правилам языка C++.
+ Создание абстрактного синтаксического дерева (AST): компилятор создает структуру данных, представляющую исходный код в виде дерева, чтобы легче обрабатывать и анализировать программу.
+ Генерация промежуточного кода: компилятор генерирует промежуточный код, который может быть использован для последующей оптимизации и генерации машинного кода.
+ Семантический анализ: компилятор проверяет семантическую корректность программы, например, типы данных, правильное использование переменных и функций.
+ Оптимизация кода: компилятор выполняет различные оптимизации промежуточного кода, чтобы улучшить производительность и эффективность сгенерированного кода.
+ Генерация объектного кода: компилятор генерирует объектный код, который представляет собой исполнимый код для конкретной архитектуры процессора.  

### Линковщик  

Линковщик - это последний этап процесса компиляции программы на C++. Он объединяет объектные файлы и библиотеки в один исполняемый файл.  

Линковщик выполняет следующие задачи:  

+ Связывание объектных файлов: линковщик объединяет несколько объектных файлов, полученных в результате компиляции исходных файлов на C++, в один исполняемый файл или библиотеку.  

+ Разрешение символов: линковщик разрешает ссылки на символы (такие как функции, переменные или классы), которые могут быть определены в разных файловых модулях. Он связывает объявления символов с их определениями и устанавливает правильные адреса их расположения в памяти.  

+ Разрешение внешних зависимостей: линковщик обрабатывает зависимости от внешних библиотек или модулей, устанавливая правильные адреса для вызовов функций или доступа к переменным, которые объявлены и определены в других модулях.  

+ Обработка таблиц символов: линковщик создает таблицы символов, которые содержат информацию о символах, их типах, адресах и других атрибутах. Эти таблицы используются компилятором, операционной системой и другими инструментами для обработки и исполнения программы.  

+ Управление памятью: линковщик распределяет и управляет памятью, необходимой для загрузки и выполнения программы. Он определяет, какие разделы памяти должны быть зарезервированы для исполняемого файла, статических и динамических переменных, стека вызовов функций и других компонентов программы.  

+ Поддержка динамической загрузки: линковщик может обрабатывать динамически загружаемые модули и библиотеки, которые могут быть загружены и выгружены в процессе выполнения программы. Он разрешает ссылки на символы, содержащиеся в этих модулях, и обновляет таблицы символов и адресные ссылки, чтобы отразить новые адреса их расположения в памяти.  

+ Оптимизация исполняемого кода: линковщик может применять различные оптимизации к исполняемому коду, такие как удаление неиспользуемого кода, сокращение размера исполняемого файла, переупорядочение инструкций для улучшения производительности и другие.  

**Внешняя линковка:**  

**Определение:** Это процесс связывания символических ссылок на функции или переменные во внешнем объектном модуле или библиотеке с их фактическими адресами во время компоновки программы.  

**Конфликт:** Возникает, когда во внешних модулях или библиотеках существуют несколько символических ссылок с одинаковыми именами на функции или переменные. При компоновке программы возникает ошибка "Multiple Definition" (множественное определение), так как компилятор не может разрешить, какая ссылка использовать.  

**Внутренняя линковка:**  

**Определение:** Это процесс связывания символических ссылок на функции или переменные в пределах одного объектного модуля с их фактическими адресами во время компиляции программы.  
**Конфликт:** Возникает, когда внутри объектного модуля существуют несколько символических ссылок с одинаковыми именами на функции или переменные, расположенные в разных частях кода. При компиляции программы возникает ошибка "Multiple Definition" (множественное определение), так как компилятор не может выбрать, какая ссылка использовать.
Решение конфликтов внешней и внутренней линковки включает в себя изменение имен символических ссылок, объявление ссылок как статических, использование специальных директив компилятора или линкера, которые разрешают данный конфликт.  

4)**Простейшая программа**  

    #include <iostream>

    int main() {

    int x = 0, y = 0;
    while (true) {

        std::cout << "Print x, y: ";
        std::cin >> x >> y;
        if (std::cin.fail()) {
        std::cin.clear();
        std::cin.ignore(32767, '\n');
        std::cout << "Oops, that input is invalid. Please try again.\n";

        } else {
        break;
        }
    }

    x = x + y;
    y = x - y;
    x = x - y;

    std::cout << x << " " << y;
    return 0;
    }  

5)**Объекты и значения**  

В C++ объект - это экземпляр класса, который имеет собственное состояние и поведение. Класс определяет структуру и поведение объектов, а объекты используются для создания конкретных экземпляров класса.  

Для создания объекта в C++ используется оператор new, который выделяет память для объекта и вызывает конструктор класса.  

Значения, с другой стороны, являются конкретными данными, хранящимися в памяти, которые могут быть присвоены объектам или переменным. Значения могут быть числами, символами, строками и другими типами данных.  

6)**Правила именования**  

### Имена переменных  

+ Должны начинаться с буквы или символа подчеркивания (_).  
+ Могут содержать буквы, цифры и символ подчеркивания.  
+ Регистр имеет значение, поэтому "myVar" и "myvar" будут разными переменными.  
+ Не должны быть ключевыми словами языка C++.  
+ Рекомендуется использовать осмысленные имена переменных, отражающие их назначение.  

### Имена функций  

+ Должны начинаться с буквы или символа подчеркивания (_).  
+ Могут содержать буквы, цифры и символ подчеркивания.  
+ Регистр имеет значение.  
+ Не должны быть ключевыми словами языка C++.  
+ Рекомендуется использовать осмысленные имена функций, отражающие их действие или назначение.  

### Имена классов  

+ Должны начинаться с буквы.  
+ Могут содержать буквы, цифры и символы подчеркивания.  
+ Регистр имеет значение.  
+ Не должны быть ключевыми словами языка C++.  
+ Рекомендуется использовать CamelCase стиль именования, где каждое новое слово начинается с заглавной буквы.  

### Имена пространств имен  

+ Должны начинаться с буквы.  
+ Могут содержать буквы, цифры и символы подчеркивания.  
+ Регистр имеет значение.  
+ Не должны быть ключевыми словами языка C++.  
+ Рекомендуется использовать имена, которые отражают содержимое пространства имен.  

### Имена констант  

+ Обычно записываются заглавными буквами с использованием символа подчеркивания (_).  
+ Могут содержать буквы и цифры.  
+ Рекомендуется использовать осмысленные имена констант, отражающие их значения или назначение.  

7)**Объявление, определение и инициализация**  

+ Объявление предоставляет компилятору информацию о типе и имени переменной или функции, без выделения памяти.  

+ Определение резервирует память и инициализирует переменные или определяет тело функции.Определение переменной может быть выполнено в любом месте программы после объявления.  

+ Инициализация присваивает начальное значение переменной при создании.Инициализация может быть выполнена вместе с объявлением или отдельно после определения переменной  

8)**Фундаментальные типы данных**  

Целочисленный тип данных (Integer): Используется для хранения целых чисел без десятичных знаков. Некоторые из наиболее распространенных целочисленных типов данных в C++ включают int, short, long и long long. 4 байта

Тип данных с плавающей запятой (Floating-point): Используется для хранения чисел с плавающей точкой, то есть чисел с десятичной частью. вещественный тип одинарной точности 4 байта.  

Символьный тип данных (Character): Используется для хранения отдельных символов. В C++ символы объявляются с помощью типа данных char. Переменная char может содержать как отдельный символ, так и целые числа в диапазоне от -128 до 127 (если используется ASCII-кодировка).

Логический тип данных (Boolean): Используется для хранения значения истины (true) или лжи (false). В C++ логическое значение объявляется с помощью типа данных bool.

Тип данных void: Используется для указания, что функция не возвращает значения или что указатель не указывает на конкретный тип данных. Тип данных void обычно используется в объявлениях функций без параметров или указателей на функции.

+ int: целочисленный тип
+ char: символьный тип
+ float: вещественный тип одинарной точности
+ double: вещественный тип двойной точности
+ bool: логический тип

bool: 1 байт
char: 1 байт
wchar_t: 2 или 4 байта (в зависимости от компилятора и определений)
short: 2 байта
int: 4 байта
long: 4 или 8 байт (в зависимости от компилятора и операционной системы)
long long: 8 байт
float: 4 байта
double: 8 байт
long double: 8 или 16 байт (в зависимости от компилятора и операционной системы)
указатель: 4 или 8 байт (в зависимости от компилятора и операционной системы)

9)**Приведение типов**  

+ Явное приведение типов:  

Статическое приведение типов: Для выполнения статического приведения типов в C++, используется оператор static_cast.  

Разыменование указателя: Если у вас есть указатель на один тип данных, и вы хотите его привести к другому типу данных, вы можете использовать оператор static_cast.  

+ Неявное приведение типов:  

Арифметические операции: Когда переменные разных типов участвуют в арифметических операциях, например сложении, вычитании, умножении или делении, C++ автоматически приводит переменные к общему типу данных.  

Присваивание: Если вы присваиваете переменной одного типа значение переменной другого типа, C++ автоматически приводит значение к типу переменной, в которую происходит присваивание.(Неявное приведение типов может быть удобным, но иногда может приводить к непреднамеренным ошибкам или потере данных.)  

10)**Проблема переносимости**  

Возможные причины проблемы переносимости с++:  

+ Различия в стандартах языка: различные версии языка могут поддерживать разные функции, библиотеки или синтаксис, что может вызвать проблемы с переносимостью.  

+ Различия в компиляторах и средах разработки: разные компиляторы могут иметь разные реализации стандартов языка, что может приводить к несоответствию ожидаемого поведения программы. Различия в средах разработки также могут повлиять на процесс сборки и настройки программы.  

+ Различия в аппаратных платформах и операционных системах: разные платформы могут иметь разные архитектуры процессоров, размеры и форматы данных, системные ресурсы и интерфейсы, что может потребовать изменений в программе при переносе на другую платформу.  

+ Использование нестандартных библиотек или зависимостей: если программа зависит от сторонних библиотек или зависимостей, которые не поддерживаются на других платформах, это может привести к проблемам при переносе.  

Чтобы улучшить переносимость программы на C++, можно использовать следующие подходы:  

+ Стремиться к написанию стандартного и переносимого кода, избегая непосредственных операций с памятью и зависимостей от конкретных платформ или компиляторов.  

+ Использовать кросс-платформенные библиотеки и инструменты, которые обеспечивают совместимость с различными платформами и операционными системами, такие как Qt или Boost.  

+ Тестируйте и отлаживайте программу на разных платформах, чтобы обнаружить и исправить возможные проблемы с переносимостью.  

+ При разработке программы учитывайте возможные ограничения и различия в аппаратных платформах и операционных системах, чтобы избежать проблем с переносимостью.  

11)**Базовые конструкции языка (условные выражения, циклы, оператор __**switch-case**__)**  

Условные выражения:  

Условные выражения позволяют программе выполнять определенный блок кода только при выполнении определенного условия.
Основной вид условного выражения в языке C++ - это оператор if-else. Он имеет следующий синтаксис:  

    if (условие) {
        // Блок кода, который будет выполнен, если условие истинно
    } else {
        // Блок кода, который будет выполнен, если условие ложно
    }  

Кроме того, в языке C++ можно использовать оператор else if, чтобы проверять несколько условий подряд:  

    if (условие1) {
        // Блок кода, который будет выполнен, если условие1 истинно
    } else if (условие2) {
        // Блок кода, который будет выполнен, если условие1 ложно и условие2 истинно
    } else {
        // Блок кода, который будет выполнен, если ни одно из условий не является истинным
    }  

Циклы:  
Циклы позволяют выполнять определенный блок кода несколько раз.
В языке C++ есть несколько типов циклов, но наиболее часто используемые - это цикл for и цикл while.  

    for (инициализация; условие; инкремент) {
        // Блок кода, который будет выполняться до тех пор, пока условие истинно
    }  
Здесь, "инициализация" выполняет начальную настройку, "условие" проверяет, должен ли цикл продолжаться, а "инкремент" выполняет операции после каждой итерации.  

    while (условие) {
        // Блок кода, который будет выполняться до тех пор, пока условие истинно
    }  
Здесь "условие" проверяется перед каждой итерацией цикла. Если оно истинно, то выполнится блок кода.  

Оператор switch-case:  
Оператор switch-case используется для выбора одного из множества возможных вариантов выполнения кода,
в зависимости от значения определенной переменной или выражения.  

    switch (выражение) {
        case значение1:
            // Блок кода, который будет выполняться, если выражение равно значению1
            break;
        case значение2:
            // Блок кода, который будет выполняться, если выражение равно значению2
            break;
        // ...
        default:
            // Блок кода, который будет выполняться, если выражение не равно ни одному из значений
            break;
    }  
В этом операторе каждый case представляет собой вариант, который будет выполняться,
если выражение равно определенному значению. После выполнения каждого блока кода следует оператор break,
чтобы выйти из оператора switch-case и продолжить выполнение программы за его пределами.  

12)**IB, UB, CE**  

IB (implementation-defined behavior) - реализация определенного поведения. IB означает, что конкретное поведение программы не определено в стандарте языка C++, и оно остается на усмотрение реализации компилятора или окружения выполнения. Различные компиляторы или системы могут реализовывать такие функции по-разному, поэтому конкретное поведение программы может быть неоднозначным или неопределенным. Примеры IB могут включать в себя порядок вычисления аргументов функций, представления внутренних числовых типов данных или использование определенных элементов языка.  

UB (undefined behavior) - неопределенное поведение. UB означает, что поведение программы не определено стандартом языка C++ и может привести к неожиданным и непредсказуемым результатам. Встречая UB, компилятор или окружение выполнения могут выполнять любые действия, включая выдачу ошибок, некорректное поведение или падение программы. Примеры UB могут включать разыменование нулевого указателя, выход за границу массива или переполнение числового типа.  

CE (compilation error) - ошибка компиляции. CE означает, что компилятор обнаружил ошибку в исходном коде программы и не может успешно скомпилировать его в исполняемый бинарный файл. Ошибки компиляции могут быть вызваны синтаксическими ошибками, неверным использованием ключевых слов или функций языка, неправильными типами данных и другими подобными проблемами. Когда возникает CE, компилятор обычно выдает сообщение об ошибке, которое помогает программисту исправить проблему.  

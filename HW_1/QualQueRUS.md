# Ответы на качественные вопросы
## Задание 1 (основные характеристики языка C++)
--скомпилированный язык  
--мультипарадигмальный язык (__*Императивное программирование*__, __*Структурное программирование*__, __*ООП*__, __*Функциональное программирование*__, __* Обобщенное программирование*__, __*Метапрограммирование*__)  
--строгая статистическая типизация  
--поддержка высокоуровневых и низкоуровневых возможностей  

## Задание 2 (основные типы данных)
--**bool**: занимает 1 байт, а не бит  
переменная этого типа может иметь значения true и false  
--**символ**: 1 байт — 256 символов  
типы char, wchar_t, char8_t, char16_t и char32_t являются встроенными типами, представляющими буквенно-цифровые символы, неалфавитно-цифровые глифы и непечатаемые символы.  
--**int**: 4 байта (короткий — 2 байта; длинный — 4 байта; длинный — 8 байт), выбор по умолчанию для целых значений  
--**signed/unsigned**: параметр по умолчанию для битовых флагов  
--**size_t**: предназначен для отображения размера любого объекта в байтах: возвращает size_of и многие стандартные библиотечные функции  
--**float**: 4-байтовые переменные с плавающей точкой, которая содержит значение числа, и показатель степени, который содержит порядок возрастания числа  
--**double**: 8-байтовые переменные с плавающей точкой, которая содержит значение числа, и показателем степени, который содержит порядок возрастания числа (более точный, чем float)  
--**void**: в основном используется для объявления функций, которые не возвращают значений, или для объявления универсальных указателей на нетипизированные или произвольно типизированные данные. Любое выражение может быть явно преобразовано или приведено к типу void  

## Задание 3 (проблема переносимости)
Фактический полученный код зависит от специфики реализации конкретного компьютера и типа используемого процессора. Программа, написанная на определенном языке программирования, требует определенного компилятора для преобразования в машинный код для данного процессора.  
### А как насчет C++
> C++ на уровне операционной системы характеризуется теми же проблемами переносимости, что и C, а также рядом своих собственных. Одна из дополнительных проблем заключается в том, что компилятор GNU с открытым исходным кодом для C++ сильно отстает от коммерческих реализаций  
### Способы предотвращения
-- Например, вы должны отделить интерфейсную часть кода от реализации, чтобы отделить ту часть программы и те модули, которые взаимодействуют с операционной системой  
-- Чтобы обеспечить переносимость кода между операционными системами и компиляторами, следует избегать использования платформозависимых библиотек при разработке различных модулей  
--Один из способов повысить переносимость программы - сделать параметры независимыми от системы или процессора с помощью макроса #define. Это сделает параметры независимыми от операционной системы или процессора  

## Задание 4 (объявление, инициализация, определение и присвоение)
--декларация: В декларации указывается уникальное название объекта, а также информация о его типе и других характеристиках  

    #include <string>

    int f(int i); // forward declaration

    int main()
    {
        const double pi = 3.14; //OK
        int i = f(2); //OK. f is forward-declared
        C obj; // error! C not yet declared.
        std::string str; // OK std::string is declared in <string> header
        j = 0; // error! No type specified.
        auto k = 0; // OK. type inferred as int by compiler.
    }

    int f(int i)
    {
        return i + 42;
    }

    namespace N {
    class C{/*...*/};
    }  
    
--определение: определение предоставляет компилятору всю информацию, необходимую для создания машинного кода, когда объект впоследствии используется в программе  

    // Declare and define int variables i and j.
        int i;
        int j = 10;

        // Declare enumeration suits.
        enum suits { Spades = 1, Clubs, Hearts, Diamonds };

        // Declare class CheckBox.
        class CheckBox : public Control
        {
        public:
            Boolean IsChecked();
            virtual int     ChangeState() = 0;
        };  

--инициализация: инициализатор определяет начальное значение переменной.  

    int i = 3;
    Point p1{ 1, 2 };  

--присваивание: простое присваивание, при котором значение второго операнда сохраняется в объекте, указанном первым операндом  
составное присваивание, при котором перед сохранением результата выполняется арифметическая операция, операция сдвига или побитовая операция  

        // expre_Assignment_Operators.cpp
        // compile with: /EHsc
        // Demonstrate assignment operators
        #include <iostream>

        int main() {
        int a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555;

        a += b;      // a is 9
        b %= a;      // b is 6
        c >>= 1;      // c is 5
        d |= e;      // Bitwise--d is 0xFFFF

        std::cout  << "a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555" << std::endl
            << "a += b yields " << a << std::endl
            << "b %= a yields " << b << std::endl
            << "c >>= 1 yields " << c << std::endl
            << "d |= e yields " << std::hex << d << std::endl;
        }  

## Задание 5 (расклад)
> Выравнивание помогает процессору эффективно извлекать данные из памяти: меньше пропусков/сбросов в кэш, меньше транзакций по шине и т.д.    
Доступ к некоторым типам памяти (например, RDRAM, DRAM и т.д.) должен осуществляться структурированным образом (выровненные "слова" и в "пакетных транзакциях", т.е. много слов одновременно) для получения эффективных результатов.



